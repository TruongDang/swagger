import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ACL {
    "read": Read;
    "write": Write;
}

export class Allow {
    "user": Array<string>;
    "role": Array<string>;
}

export class BoolFilter {
    "bool": SearchFilter;
}

export class BoolQuery {
    "bool": SearchQuery;
}

export class Cache {
    "type": string;
    "name": string;
    "size": string;
}

export class CacheItem {
    "key": string;
    "value": string;
}

export class CacheRequest {
    "item": string;
    "key": string;
}

export class CloudFile {
    "id": string;
    "type": string;
    "aCL": ACL;
    "name": string;
    "size": number;
    "url": string;
    "expires": Date;
    "contentType": string;
}

export class CloudObject extends null<String, any> {
}

export class CloudObjectSaveRequest {
    "key": string;
    "document": CloudObject;
}

export class CloudQuery {
    "key": string;
    "skip": number;
    "limit": number;
    "query": Query;
    "sort": any;
    "select": any;
}

export class CloudQueryCount extends CloudQuery {
    "sort": string;
    "select": string;
    "skip": number;
    "limit": number;
}

export class CloudQueryDistinct extends CloudQuery {
    "onKey": Array<string>;
}

export class CloudQueryFindById extends CloudQuery {
    "query": CloudQueryId;
    "limit": number;
}

export class CloudQueryFindOne extends CloudQuery {
    "limit": number;
}

export class CloudQueryId extends Query {
    "id": string;
}

export class CloudRole extends CloudObject {
}

export class CloudSearch {
    "query": FilterBody;
    "sort": Array<string>;
    "collectionName": string;
    "key": string;
    "skip": number;
    "limit": number;
}

export class CloudTable {
    "name": string;
    "appId": string;
    "type": CloudTable.TypeEnum;
    "columns": Array<Column>;
}

export namespace CloudTable {
    export enum TypeEnum { 
        user = <any> 'user',
        role = <any> 'role',
        custom = <any> 'custom'
    }
}
export class CloudTableSave {
    "data": CloudTable;
    "key": string;
}

export class CloudUser extends CloudObject {
}

export class Column {
    "name": string;
    "dataType": Column.DataTypeEnum;
    "type": string;
    "required": boolean;
    "unique": boolean;
    "relatedTo": string;
    "relationType": string;
    "isDeletable": boolean;
    "isEditable": boolean;
    "isRenamable": boolean;
}

export namespace Column {
    export enum DataTypeEnum { 
        Text = <any> 'Text',
        Email = <any> 'Email',
        URL = <any> 'URL',
        Number = <any> 'Number',
        Boolean = <any> 'Boolean',
        DateTime = <any> 'DateTime',
        GeoPoint = <any> 'GeoPoint',
        File = <any> 'File',
        List = <any> 'List',
        Relation = <any> 'Relation',
        Object = <any> 'Object',
        Id = <any> 'Id',
        EncryptedText = <any> 'EncryptedText',
        ACL = <any> 'ACL'
    }
}
export class Deny {
    "user": Array<string>;
    "role": Array<string>;
}

export class EmailBody {
    "email": string;
    "key": string;
}

export class FileBody {
    "key": string;
    "data": string;
    "fileObj": CloudFile;
}

export class FilterBody {
    "filtered": Filtered;
}

export class Filtered {
    "query": BoolQuery;
    "filter": BoolFilter;
}

export class KeyBody {
    "key": string;
}

export class ModifiedQueue {
    "aCL": ACL;
    "type": string;
    "expires": Date;
    "queueType": string;
    "retry": string;
    "name": string;
    "subscribers": Array<string>;
    "isModified": boolean;
    "modifiedColumns": Array<string>;
    "messages": Array<QueueMessage>;
}

export class ModifiedQueueBody {
    "document": ModifiedQueue;
    "key": string;
}

export class PasswordChangeBody {
    "oldPassword": string;
    "newPassword": string;
    "key": string;
}

export class Query {
    "$IncludeList": Array<string>;
    "$Include": Array<string>;
}

export class Queue {
    "id": string;
    "tableName": string;
    "createdAt": Date;
    "updatedAt": Date;
    "aCL": ACL;
    "type": string;
    "expires": Date;
    "queueType": string;
    "retry": string;
    "name": string;
    "subscribers": Array<string>;
    "messages": Array<QueueMessage>;
}

export class QueueBody {
    "document": Queue;
    "key": string;
}

export class QueueMessage {
    "aCL": ACL;
    "type": string;
    "expires": Date;
    "id": string;
    "delay": Date;
    "timeout": number;
    "modifiedColumns": Array<string>;
    "isModified": boolean;
    "message": string;
}

export class QueuePayloadWithCount {
    "count": number;
    "key": string;
}

export class Read {
    "allow": Allow;
    "deny": Deny;
}

export class RefreshMessageTimeoutBody {
    "timeout": number;
    "key": string;
}

export class RoleBody {
    "key": string;
    "document": CloudRole;
}

export class SearchFilter {
    "mustNot": Array<string>;
    "should": Array<string>;
    "must": Array<string>;
}

export class SearchQuery {
    "mustNot": Array<string>;
    "should": Array<string>;
    "must": Array<string>;
}

export class UserBody {
    "key": string;
    "document": CloudUser;
}

export class UserRoleBody {
    "key": string;
    "role": CloudRole;
    "user": CloudUser;
}

export class Write {
    "allow": Allow;
    "deny": Deny;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class CloudCacheApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * clear all items from a cloud cache
     * clear all items from a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public clearCache (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<CacheRequest>;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/clear'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling clearCache');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling clearCache');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling clearCache');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CacheRequest>;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * create a cloud cache
     * create a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public createCache (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Cache;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/create'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling createCache');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling createCache');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling createCache');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Cache;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete all CloudCaches
     * delete all CloudCaches
     * @param appId Id of CloudApp
     * @param body master key of app
     */
    public deleteAllCache (appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<CacheRequest>;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteAllCache');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteAllCache');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CacheRequest>;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete a CloudCache
     * delete a CloudCache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public deleteCache (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: CacheRequest;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteCache');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling deleteCache');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteCache');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CacheRequest;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete item from a cloud cache
     * delete item from a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param dataKey key under which data to delete is cached
     * @param body master key of app
     */
    public deleteItem (appId: string, cacheName: string, dataKey: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/item/{data_key}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName))
            .replace('{' + 'data_key' + '}', String(dataKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteItem');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling deleteItem');
        }

        // verify required parameter 'dataKey' is set
        if (!dataKey) {
            throw new Error('Missing required parameter dataKey when calling deleteItem');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteItem');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get all CloudCaches
     * get all CloudCaches
     * @param appId Id of CloudApp
     * @param body master key of app
     */
    public getAllCache (appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<Cache>;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getAllCache');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getAllCache');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Cache>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get all items from a cloud cache
     * get all items from a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public getAllItems (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<CacheItem>;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/items'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getAllItems');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling getAllItems');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getAllItems');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CacheItem>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get info about a CloudCache
     * get info about a CloudCache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public getCacheInfo (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Cache;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getCacheInfo');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling getCacheInfo');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getCacheInfo');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Cache;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get item from a cloud cache
     * get item from a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param dataKey key under which data should be got in cache
     * @param body master key of app
     */
    public getItem (appId: string, cacheName: string, dataKey: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/{data_key}/item'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName))
            .replace('{' + 'data_key' + '}', String(dataKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getItem');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling getItem');
        }

        // verify required parameter 'dataKey' is set
        if (!dataKey) {
            throw new Error('Missing required parameter dataKey when calling getItem');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getItem');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * count items in a cloud cache
     * count items in a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param body master key of app
     */
    public getItemsCount (appId: string, cacheName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/items/count'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getItemsCount');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling getItemsCount');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getItemsCount');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: number;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * add item to a cloud cache
     * add item to a cloud cache
     * @param appId Id of CloudApp
     * @param cacheName Name of cache
     * @param dataKey key under which data should be store in cache
     * @param body cache data and master key included got from this object
     */
    public set (appId: string, cacheName: string, dataKey: string, body: CacheRequest) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'cache/{app_id}/{cache_name}/{data_key}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'cache_name' + '}', String(cacheName))
            .replace('{' + 'data_key' + '}', String(dataKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling set');
        }

        // verify required parameter 'cacheName' is set
        if (!cacheName) {
            throw new Error('Missing required parameter cacheName when calling set');
        }

        // verify required parameter 'dataKey' is set
        if (!dataKey) {
            throw new Error('Missing required parameter dataKey when calling set');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling set');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudFileApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * deletes file
     * 
     * @param appId ID of app
     * @param fileId file id
     * @param body request body
     */
    public deleteFile (appId: string, fileId: string, body?: KeyBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'file/{app_id}/{file_id}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'file_id' + '}', String(fileId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteFile');
        }

        // verify required parameter 'fileId' is set
        if (!fileId) {
            throw new Error('Missing required parameter fileId when calling deleteFile');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * fetch file content
     * 
     * @param appId ID of app
     * @param fileId file id
     * @param body request body
     */
    public fetchFileContent (appId: string, fileId: string, body?: KeyBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'file/{app_id}/{file_id}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'file_id' + '}', String(fileId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling fetchFileContent');
        }

        // verify required parameter 'fileId' is set
        if (!fileId) {
            throw new Error('Missing required parameter fileId when calling fetchFileContent');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * uploads a file
     * 
     * @param appId ID of app
     * @param fileObj file extra data
     * @param key app key
     * @param fileToUpload file to upload
     */
    public saveFile (appId: string, fileObj: string, key?: string, fileToUpload?: any) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'file/{app_id}'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling saveFile');
        }

        // verify required parameter 'fileObj' is set
        if (!fileObj) {
            throw new Error('Missing required parameter fileObj when calling saveFile');
        }

        let useFormData = false;

        if (key !== undefined) {
            formParams['key'] = key;
        }

        if (fileObj !== undefined) {
            formParams['fileObj'] = fileObj;
        }

        if (fileToUpload !== undefined) {
            formParams['fileToUpload'] = fileToUpload;
        }
        useFormData = true;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * uploads a file with data
     * 
     * @param myAppId ID of app
     * @param fileObj file extra data
     */
    public saveFileData (myAppId: string, fileObj: FileBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'file/{my_app_id}'
            .replace('{' + 'my_app_id' + '}', String(myAppId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'myAppId' is set
        if (!myAppId) {
            throw new Error('Missing required parameter myAppId when calling saveFileData');
        }

        // verify required parameter 'fileObj' is set
        if (!fileObj) {
            throw new Error('Missing required parameter fileObj when calling saveFileData');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: fileObj,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudObjectApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * deletes a cloud object from cloudapp
     * deletes a cloud object from cloudapp
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body CloudObject that needs to be added to the cloudboost
     */
    public _delete (appId: string, tableName: string, body: CloudObjectSaveRequest) : Promise<{ response: http.ClientResponse; body: CloudObject;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling _delete');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling _delete');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling _delete');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudObject;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * saves a cloud object to cloudboost
     * 
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body CloudObject that needs to be added to cloudboost
     */
    public save (appId: string, tableName: string, body: CloudObjectSaveRequest) : Promise<{ response: http.ClientResponse; body: CloudObject;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling save');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling save');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling save');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudObject;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudQueryApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * count items in a table that match this query criteria
     * count items in a table that match this query criteria
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body query body
     */
    public count (appId: string, tableName: string, body: CloudQueryCount) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}/count'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling count');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling count');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling count');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: number;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * distinct query criteria
     * 
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body query body
     */
    public distinct (appId: string, tableName: string, body: CloudQueryDistinct) : Promise<{ response: http.ClientResponse; body: Array<CloudObject>;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}/distinct'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling distinct');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling distinct');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling distinct');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CloudObject>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * find CloudObject meeting this query criteria
     * 
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body query object
     */
    public find (appId: string, tableName: string, body: CloudQuery) : Promise<{ response: http.ClientResponse; body: Array<CloudObject>;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}/find'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling find');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling find');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling find');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CloudObject>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * find CloudObject with specific _id
     * 
     * @param cloudAppId CloudApp id
     * @param tableName cloud table name
     * @param body query body
     */
    public findById (cloudAppId: string, tableName: string, body: CloudQueryFindById) : Promise<{ response: http.ClientResponse; body: CloudObject;  }> {
        const localVarPath = this.basePath + 'data/{cloud_app_id}/{table_name}/find'
            .replace('{' + 'cloud_app_id' + '}', String(cloudAppId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cloudAppId' is set
        if (!cloudAppId) {
            throw new Error('Missing required parameter cloudAppId when calling findById');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling findById');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling findById');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudObject;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * find a single CloudObject
     * 
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body query body
     */
    public findOne (appId: string, tableName: string, body: CloudQueryFindOne) : Promise<{ response: http.ClientResponse; body: CloudObject;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}/findOne'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling findOne');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling findOne');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling findOne');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudObject;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudQueueApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * push message to queue
     * add message message to queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public addMessage (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/message'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling addMessage');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling addMessage');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling addMessage');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * add a subscriber to this queue
     * add a subscriber to this queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body payload
     */
    public addSubscriber (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/subscriber'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling addSubscriber');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling addSubscriber');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling addSubscriber');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * clear queue
     * clear queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public clear (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/clear'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling clear');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling clear');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling clear');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * create a new queue
     * add message message to queue
     * @param appId Id of CloudApp
     * @param queueName name of queue
     * @param body client key of app
     */
    public createQueue (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/create'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling createQueue');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling createQueue');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling createQueue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete a message in this queue
     * delete a message in this queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param messageId message id
     * @param body client key of app
     */
    public deleteMessage (appId: string, queueName: string, messageId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/message/{message_id}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName))
            .replace('{' + 'message_id' + '}', String(messageId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteMessage');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling deleteMessage');
        }

        // verify required parameter 'messageId' is set
        if (!messageId) {
            throw new Error('Missing required parameter messageId when calling deleteMessage');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteMessage');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete a queue
     * delete queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public deleteQueue (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteQueue');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling deleteQueue');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteQueue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * delete a subscriber to this queue
     * delete a subscriber to this queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body payload
     */
    public deleteSubscriber (appId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/subscriber'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteSubscriber');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling deleteSubscriber');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteSubscriber');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * push message to queue
     * add message message to queue
     * @param appId Id of CloudApp
     * @param body client key of app
     */
    public getAllMessages (appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/messages'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getAllMessages');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getAllMessages');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get all queues
     * get all queues
     * @param appId Id of CloudApp
     * @param body client key of app
     */
    public getAllQueues (appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Array<Queue>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getAllQueues');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getAllQueues');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Queue>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get messages in queue
     * get messages in queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public getMessage (appId: string, queueName: string, body: QueuePayloadWithCount) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/getMessage'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getMessage');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling getMessage');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getMessage');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get a message in this queue by its id
     * get a message in this queue by its id
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param messageId message id
     * @param body client key of app
     */
    public getMessageById (appId: string, queueName: string, messageId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: QueueMessage;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/message/{message_id}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName))
            .replace('{' + 'message_id' + '}', String(messageId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getMessageById');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling getMessageById');
        }

        // verify required parameter 'messageId' is set
        if (!messageId) {
            throw new Error('Missing required parameter messageId when calling getMessageById');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getMessageById');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: QueueMessage;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * get queue
     * get queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public getQueue (appId: string, queueName: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getQueue');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling getQueue');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getQueue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Queue;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * peek messages in queue without removing them
     * peek messages in queue without removing them
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public peek (appId: string, queueName: string, body: QueuePayloadWithCount) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/peek'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling peek');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling peek');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling peek');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * peek messages in queue without removing them
     * peek messages in queue without removing them
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public peekMessage (appId: string, queueName: string, body: QueuePayloadWithCount) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/peekMessage'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling peekMessage');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling peekMessage');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling peekMessage');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * pull messages from queue
     * pull messages from queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public pull (appId: string, queueName: string, body: QueuePayloadWithCount) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/pull'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling pull');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling pull');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling pull');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * refresh timeout of a message in this queue
     * refresh timeout of a message in this queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param messageId message id
     * @param body client key of app
     */
    public refreshMessageTimeout (appId: string, queueName: string, messageId: string, body: RefreshMessageTimeoutBody) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}/{message_id}/refresh-message-timeout'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName))
            .replace('{' + 'message_id' + '}', String(messageId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling refreshMessageTimeout');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling refreshMessageTimeout');
        }

        // verify required parameter 'messageId' is set
        if (!messageId) {
            throw new Error('Missing required parameter messageId when calling refreshMessageTimeout');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling refreshMessageTimeout');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * push message to queue
     * add message message to queue
     * @param myAppId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public updateMessage (myAppId: string, queueName: string, body: QueueBody) : Promise<{ response: http.ClientResponse; body: Array<QueueMessage>;  }> {
        const localVarPath = this.basePath + 'queue/{my_app_id}/{queue_name}/message'
            .replace('{' + 'my_app_id' + '}', String(myAppId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'myAppId' is set
        if (!myAppId) {
            throw new Error('Missing required parameter myAppId when calling updateMessage');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling updateMessage');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling updateMessage');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<QueueMessage>;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * update queue
     * update queue
     * @param appId Id of CloudApp
     * @param queueName Name of queue
     * @param body client key of app
     */
    public updateQueue (appId: string, queueName: string, body: ModifiedQueueBody) : Promise<{ response: http.ClientResponse; body: ModifiedQueue;  }> {
        const localVarPath = this.basePath + 'queue/{app_id}/{queue_name}'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'queue_name' + '}', String(queueName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling updateQueue');
        }

        // verify required parameter 'queueName' is set
        if (!queueName) {
            throw new Error('Missing required parameter queueName when calling updateQueue');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling updateQueue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ModifiedQueue;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudRoleApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new cloudrole
     * 
     * @param appId ID of app
     * @param body request body
     */
    public createRole (appId: string, body: RoleBody) : Promise<{ response: http.ClientResponse; body: CloudRole;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/Role'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling createRole');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling createRole');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudRole;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudSearchApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * search for cloudobjects following the criteria defined herein
     * 
     * @param appId CloudApp id
     * @param tableName cloud table name
     * @param body query body
     */
    public search (appId: string, tableName: string, body: CloudSearch) : Promise<{ response: http.ClientResponse; body: Array<CloudObject>;  }> {
        const localVarPath = this.basePath + 'data/{app_id}/{table_name}/search'
            .replace('{' + 'app_id' + '}', String(appId))
            .replace('{' + 'table_name' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling search');
        }

        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling search');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling search');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<CloudObject>;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudTableApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * delete a cloud table
     * @param tableName name of cloud table
     * @param appId cloud app id
     * @param body master key and app id
     */
    public deleteTable (tableName: string, appId: string, body: CloudTableSave) : Promise<{ response: http.ClientResponse; body: CloudTable;  }> {
        const localVarPath = this.basePath + 'app/{app_id}/{table_name}'
            .replace('{' + 'table_name' + '}', String(tableName))
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling deleteTable');
        }

        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling deleteTable');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling deleteTable');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudTable;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * get a table
     * @param tableName name of cloud table
     * @param appId id of app
     * @param body master key and app id
     */
    public get (tableName: string, appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body: CloudTable;  }> {
        const localVarPath = this.basePath + 'app/{app_id}/{table_name}'
            .replace('{' + 'table_name' + '}', String(tableName))
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling get');
        }

        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling get');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling get');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudTable;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * get all tables in app
     * @param appId app id
     * @param body master key
     */
    public getAll (appId: string, body: KeyBody) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/app/{app_id}/_getAll'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling getAll');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling getAll');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * save a cloud table
     * @param tableName name of cloud table
     * @param appId cloud app id
     * @param body master key and app id
     */
    public save (tableName: string, appId: string, body: CloudTableSave) : Promise<{ response: http.ClientResponse; body: CloudTable;  }> {
        const localVarPath = this.basePath + 'app/{app_id}/{table_name}'
            .replace('{' + 'table_name' + '}', String(tableName))
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling save');
        }

        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling save');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling save');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudTable;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CloudUserApi {
    protected basePath = 'http://api.cloudboost.io/';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * add a user to a role
     * 
     * @param appId ID of app
     * @param body request body
     */
    public addToRole (appId: string, body: UserRoleBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/addToRole'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling addToRole');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling addToRole');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * change a password
     * changes the password for a logged in user without logging them out
     * @param appId ID of app
     * @param body request body
     */
    public changePassword (appId: string, body: PasswordChangeBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/changePassword'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling changePassword');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling changePassword');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * login existing user
     * 
     * @param appId ID of app
     * @param body request body
     */
    public login (appId: string, body: UserBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/login'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling login');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling login');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * logout user
     * 
     * @param appId ID of app
     * @param body request body
     */
    public logout (appId: string, body: UserBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/logout'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling logout');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling logout');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * remove a user from a role
     * 
     * @param appId ID of app
     * @param body request body
     */
    public removeFromRole (appId: string, body: UserRoleBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/removeFromRole'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling removeFromRole');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling removeFromRole');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * reset a password
     * sends a password reset link to the given email
     * @param appId ID of app
     * @param body request body
     */
    public resetPassword (appId: string, body: EmailBody) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/resetPassword'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling resetPassword');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling resetPassword');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * create a new user
     * 
     * @param appId ID of app
     * @param body request body
     */
    public signUp (appId: string, body: UserBody) : Promise<{ response: http.ClientResponse; body: CloudUser;  }> {
        const localVarPath = this.basePath + 'user/{app_id}/signup'
            .replace('{' + 'app_id' + '}', String(appId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'appId' is set
        if (!appId) {
            throw new Error('Missing required parameter appId when calling signUp');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling signUp');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CloudUser;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
